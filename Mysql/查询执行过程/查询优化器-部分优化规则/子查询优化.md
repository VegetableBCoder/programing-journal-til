# 子查询优化

## 子查询分类

### 按查询结果集类型

* 只返回一行一列(一个值)的查询称为标量子查询
* 只返回一行数据的称为行子查询
* 只返回一列的称为列子查询
* 返回多行多列的称为表子查询

### 按与外层关系

* 不相关子查询, 不依赖外层的值, 可以单独执行的子查询
* 相关子查询, 需要依赖外层的值
  
## 执行优化与分析

### 标量子查询和行子查询

* 无关标量子查询例1: ```select * from t1 where col1 = (select xxx from t2 where col2='a' limit 1)```
* 相关标量子查询例1: ```select * from t1 where t1.col1=(select xxx from t2 where t1.col2= t2.col2 limit 1)``` 

#### 无关标量/行子查询执行过程

* 无关标量子查询例1中会先执行子查询
* 然后把结果作为参数执行外层查询
* 无关行子查询的逻辑与标量子查询一致

#### 相关标量/行子查询执行过程

* 从外层获取一条数据, 找到内层子查询条件涉及的值
* 执行内层子查询
* 根据内层子查询的结果判断外层的where条件是否成立
* 如果外层where成立则把外层表的行放入结果集, 否则舍弃
* 重复以上步骤, 直到外层无法获取到记录为止
* 相关行子查询的逻辑与标量子查询一致
  
### in子查询的执行优化(列子查询)

* 例1: ```select * from t1 where col1 in (select col3 from t2 where col2=1)```

#### 优化分析

* 直观思路: 先执行子查询, 再执行外层语句(Mysql不是这么运行的)
  * 内层查询结果条数少效率可以接受, 条数多了就会性能低下
* in查询的物化表
  * 将内层表的查询结果去重作为一个临时表
    * 如果临时表不是很大就会建立一个内存表, 为这个列建立hash索引
    * 如果太大, 超出配置值就会建立磁盘临时表, 建立B+树索引
    * 将子查询的结果变成临时表之后就可以考虑通过连表的方式进行查询
* 半连接
  * 例1的sql 类似于```select t1.* from t1 inner join t2 on t1.col1=t2.col3 where t2.col2=1```
    * 区别在于t1中的数据在t2有多条关联数据时会不会重复出现在结果集中
  * Mysql提出的半连接概念: 查询结果只保留驱动表的记录, 驱动表的数据是否出现在结果集中取决于被驱动表中是否有关联数据, 而出现次数至多为1, 与被驱动表内匹配的数据条数无关
* in 子查询半连接的实现
  * 子查询表上拉
    * 如果子查询的结果列时主键或者唯一索引, 保证不会出现重复的情况, 就可以直接上拉到外层, 直接变成内连接查询
  * 重复值消除
    * 转化为连接之后创建一个临时表, 存放驱动表的id, 对结果集的每条数据尝试将id写入临时表中
    * 如果写不进临时表, 说明记录重复, 放弃假如加入结果集
  * 松散扫描
    * 如果子查询的结果列恰好就时查询的条件列, 取结果时可以按照顺序跳过一些重复记录 使子查询结果有序
  * 半物化连接
    * 上文提到的物化表建立后, 将外层表与内层表进行连接的查询方式称为半物化连接
  * 首次匹配
    * 这种方式的执行与我们另一种直观思路类似: 对每一条外层shuj, 到子查询的表中判断是否存在关联数据
    * 如果存在加将外层数据加入结果集, 否则丢弃
  * 使用半连接的条件
    * 形如 ```select ... from out_table where expr in (select ... from inner_table ...) AND ...```
    * 形如 ``` select ... from out_table where expr1, expr2 in( select ie1, ie2 from inner_table where ...) AND ...```
  * 对于不能转换为半连接的in子查询
    * 不相关子查询, 可以先物化再查询, 比如 not in
    * 无论是相关不相关in子查询, 都可以尝试转换为exists子查询, 比较执行成本

### ANY/ALL查询

* ANY/ALL表达式通常都能转化为聚合函数的标量子查询

| 原始表达式        | 转化结果            |
| ----------------- | ------------------- |
| < ANY(select xxx) | < (select max(xxx)) |
| > ANY(SELECT xxx) | > (select mim(xxx)) |
| > ALL(select xxx) | > (select max(xxx)) |
| < ALL(select xxx) | < (select min(xxx)) |

### [NOT] EXSISTS 子查询

* 如果是无关子查询, 直接将子查询的执行结果变成常量 TRUE/FALSE 再简化查询条件
* 如果是相关子查询, 需要对外层查询的每一条数据执行一次内层查询确定是否存在关联数据
  
### 派生表优化

* 物化
* 与外层查询合并