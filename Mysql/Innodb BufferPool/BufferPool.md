# BufferPool

## 结构

* 将连续的内存划分为多个页面, 称为缓冲页, 大小与Innodb磁盘的页面大小一致, 默认都是16kb
  * 这里的连续指逻辑上连续, 操作系统层面上分给mysql的内存不一定在物理上连续
* 每个缓冲页对应一个控制块, 放在全部缓冲页的前面
* 缓冲页和控制块之间可能由于空间有剩余的原因存在碎片

## Free链表

* 将空闲页面的控制块放在一个链表中, 称为Free链表
  * 为链表创建一个基节点, 记录链表的头, 尾块位置和链表长度, 基节点不属于BufferPool
* 需要分配或回收页面时, 从链表上取一个控制块或者将一个控制块加入链表即可

## 缓冲页的Hash映射

* 当需要读取某个页面的数据时, 需要先判断从BufferPool中取, 还是从磁盘中取
* 遍历BufferPool的页面自然不现实, 所以可以建立一个Hash表, 存放表空间号+页号和对应的控制块信息

## Flush链表

* 当修改缓冲页的内容后, 内容就和磁盘的页内容不一样了, 需要找机会把数据写到磁盘
* 被修改的缓冲页称为脏页, 如果实时将脏页写回磁盘会影响性能

### 脏页的管理

* 与Free链表类似建立一个基节点, 然后把新的脏页放入链表, 写回磁盘之后就从链表移除

## LRU链表的管理

* 加入到内存的缓冲页面需要按照LRU淘汰不使用的页面

### 基础实现方式(看起来像LFU)

* 从磁盘加载到BufferPool的页面放在LRU链表的头部
* 如果已经被加载的页面再次被使用, 则移动到链表头部
* 从链表尾部淘汰页面

### 预读机制对缓冲页面的影响

#### 预读机制

* 当从磁盘读取页面时, Innodb会把一些他认为接下来可能要使用的页面加入到BufferPool
* 线性预读: 按照程序局部性原理, 如果访问某个区的页面超过指定数, 就将下一个区的数据都加载到BufferPool
* 随机预读: 如果一个区里面13个连续页面被读取了, 那么就把整个区加入BufferPool

#### 影响

* 预读的页面都会被放在LRU链表头部, 这些预读的页面加载之后又没有使用, 可能导致其他有用的页面被淘汰
* 大表的全表扫描会导致大量的数据加载到BufferPool, 很可能把有用的缓冲页挤出BufferPool

#### 针对预读的优化

* 将链表分为两截, 分为old和young两种, 默认old占用37%
* 第一次加载到BufferPool放在old区域, 后续再被使用就放在young页面

#### 全表扫描的优化

* 如果只是分为两截, 发生全表扫描时新加入old的页面由于要扫描下一行数据必然马上又被移动到young的头部
* 规定超过一段时间再次访问才会从old移动到young

### 性能优化

* 如果位置在前1/4的节点被访问, 不会移动到头部


## Flush链表上的脏页写回磁盘

* 从LRU页面选择一部分冷的脏页刷回磁盘
* 从Flush链表刷新一部分页面到磁盘, 取决于系统是否繁忙
