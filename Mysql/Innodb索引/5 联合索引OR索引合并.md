# 联合索引

## 多条件查询的索引使用

> select * from t where a=1 and b=1

### 分别为a, b两列分别建立索引 idx_a, idx_b

* sql执行时, 优化器可能会先从索引idx_a查询出一批主键, 再从idx_b查询出一批主键
* 把查询出的两批主键交给SQL层取交集
* 回表查询数据

### 建立联合索引 idx_a_b(a,b)

* 查询时直接从idx_a_b取到一批主键, 回表查询数据

### 性能比较

* 由于index_merge需要两次检索二级索引, 并且将两次查询得到的主键交给上层取交集, 所以性能比组合索引差得多

## 最左匹配原则

* 为表t建立联合索引 idx_a_b(a,b)
* 由于索引是有序的, 查询时需要通过a/ab的值进行B+树检索, 而仅有b的条件无法按照搜索树的逻辑进行搜索, 无法使用到索引

## 范围查询问题

> 有表t, 联合索引 idx_a_b_c(a,b,c)

### 范围查询 a=1 and b>1 c>1

* a=1, a值已经确定, 正常使用联合索引
* b>1, 由于a值已经有序, 可以利用索引的有序性, 从b=1之后的行开始取
* c>1, 左边的列已经出现范围查询, 索引有序性的利用已经终端, 所以不能利用索引
  * 但是c>1可以利用索引条件下推, 这里放在其他笔记中说明

## Union合并

### 举例

* 有表t, key1, key2两列分别有一个单列索引
* select * from t where key1='a' or key2 = 'b'

### 分析

* key1 key2有单独的索引, 按照两个索引进行扫描都是单点扫描区间
* 如果考虑索引合并, 分别按照两个索引扫描之后主键都是有序的
  * 可以不借助排序算法之类辅助手段的进行去重
  * 回表时id是有序的可以提升一些效率
* 这种两个索引查询出来都是主键有序的合并称为Union合并

## Sort-Union合并

### 举例

* 有表t, key1, key2两列分别有一个单列索引
* select * from t where key1>'a' or key2 <> 'b'

### 分析

* key1 > 'a' 条件查询的主键结果序列不是完全有序, 而是多个有序的片段组成的
* key2 < 'b' 查询结果也不是有序的
* 索引合并时将两个主键序列都排序后再进行合并, 这种合并方式被称为Sort-Union


## 为啥没有Sort-Intersection

* 想一下场景: 从多个二级索引查询出来的主键太多, 回表的成本太大, 取交集之后回表成本可以降低
* 对大量主键进行排序也会消耗较多性能, 可能Mysql考量了这两个选项的性能开销区别, 没有支持这种合并方式
* Mariadb 实现了这种合并方式
