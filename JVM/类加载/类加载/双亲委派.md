# 双亲委派机制

## 如何判断是同一个类?

* 类全名相同
* 类加载器相同

## 双亲委派

* 一个类加载器收到类加载请求时不是先尝试进行类加载, 而是尝试将请求委派给父加载器进行加载, 只有父类加载不到的情况下才由自己加载
* 双亲委派机制不是强制的, 某些情况下也要打破双亲委派机制

## 类加载器

* HotSpot虚拟机角度来看, 有两种类加载器: 
  * 启动类加载器BootStrap ClassLoder, 属于虚拟机一部分, C++实现
  * 其他所有类加载器, 都继承子java.lang.ClassLoder, 都是java实现
* 从开发人员角度看, 类加载器分为三层: 启动类加载器, 扩展类加载器, 应用类加载器
  * 启动类加载器:  负责加载java_home\lib目录, 或者被-Xbootclasspath指定的目录下的类库文件
    * 启动类加载器无法被
  * 扩展类加载器: 与启动类加载器类似, 是加载java_home\lib\ext目录下的类库的加载器
  * 应用程序类加载器: 加载所有用户路径的类

## 双亲委派的好处

* 首先, 类随着加载器一起具备了优先级关系
  * 只要遵守了双亲委派机制, java.lang.Object处于java_home/lib的rt.jar中, 它们的加载器都会是启动类加载器, 不出现同一个类被不同类加载器的情况

## 破坏双亲委派模型案例

* JDK1.2: 引入双亲委派模型时的妥协: 为了兼容, 不能通过final不再允许loadClass不被覆盖, 而是添加一个新的findClass, 引导用户使用findClass, 这样用户自己的加载器既可以按照用户的想法加载类, 也符合双亲委派的规范
* JNDI: JNDI的代码在jdk核心代码中(rt.jar), JNDI的目的是对资源进行查找和集中管理, 需要调用其他厂商在用户程序目录下的代码, 顶层的类加载器肯定无法加载这些代码
  * 引入线程上下文加载器, 通过Thread的setClassLoder进行设置, 这样去破坏双亲委派模型加载服务商的类
  * 类似的还有JDBC, JCE JAXB, JBI等
  * JDK6时提供ServicerLoader, 以责任链的方式规范化这些操作
* 代码热加载, 模块热部署(oracle的Jigsaw与IBM的OSGi之争)

* Tomcat: java.*等JRE类的特殊处理
  * 其他类先在webapp内部文件里面找, 找不到再向上委派
  * 目的是避免多个war包的依赖冲突

## JDK9+: 模块化的适应

* 扩展类加载器被平台类加载器取代
  * rt.jar和tools.jar被拆成几十个mod文件
* 平台类加载器和应用程序嘞加载器都不再继承自URLClassLoader
* jdk9中仍然位置双亲委派机制, 但是委派关系有变动
  * 平台和应用类加载器判断类是否更归属到系统模块中, 如果是则优先委派给负责对应模块的加载器