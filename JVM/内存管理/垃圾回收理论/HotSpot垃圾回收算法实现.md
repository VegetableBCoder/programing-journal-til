# HotSpot垃圾回收算法实现

## 根节点枚举

* 从GCRoots区域找出根节点对象的过程
* 所有收集器的根节点枚举都是需要STW的
* 当STW之后不需要检查完所有的上下文和全局的引用位置, 可以使用OopMap(对象指针地图)来辅助快速寻找根
  * oop: ordinary object pointer, 其实就是一个对象
  * GC不管是标记清除, 标记整理, 标记复制, 都要先找到对象才能标记, 问题是对象从哪找到呢?
  * JVM采用准确式GC, 也就是说能知道哪些地方有oop, 就是通过OopMap空间换时间, 线程在到达安全点的时候根据栈和寄存器的情况生成OopMap, 然后停下来响应GC
  
## 安全点

* oop固然可以帮助快速获取GC Roots, 但是线程持续维护OopMap不仅会消耗空间, 还会消耗CPU
* HotSpot不会为每一条指令的执行都生成OopMap, 仅在部分位置记录这些信息, 这些位置被称为安全点
* 线程必须运行到安全点才能真正停下来响应GC
* 安全点的选择既不能太多过分增大运行时的性能负担, 也不能太少, 让GC等待太久
* HotSpot安全点的选择基本以"是否具有让程序长时间执行的特征"为标准进行选择, 这种特征一般出现在接下来会复用指令序列的位置, 如方法调用, 循环跳转, 异常跳转等位置
* 如何让线程中断?
  * 抢先式中断: GC发生时, 系统把所有线程停下来, 发现线程没有停在安全点上, 让它运行到下一个安全点; 目前几乎没有虚拟机用这种方式
  * 主动式中断: 设立一个标志位, 线程运行时不断检查是否需要中断, 发现为真就需要在最近的安全点上主动停下来
    * 轮询标志的地方很多都是安全点, 另外像对象创建和其他在堆上申请内存的时候也进行标志检查, 避免内存不足
    * 由于轮询操作极其频繁, 所以要足够简单, HotSpot的标志位检查只有一条汇编指令: 使用test检查某个内存地址, 如果被虚拟机设置为不可读, 产生一个自陷异常, 如果出现异常则通过异常处理器挂起线程

## 安全区域

* 如果线程没有在安全点上就被阻塞了, 无法响应GC, 这种时候就需要引入安全区域的概念
* 安全区域指在某一段代码片段内, 引用关系不会发生变化
  * 用户线程进入安全区域会标识自己进入安全区域(相当于: 我在睡觉, 家里东西我没动....)
  * 虚拟机在根节点枚举阶段, 发现一个线程在安全区域, 就无需唤醒它来响应安全点问题
  * 线程离开安全区域， 检查虚拟机是不是还在做根节点枚举， 如果不是，无事发生，继续运行，如果是，就等着，等到根节点枚举完成

## 跨代引用问题---------记忆集和卡表

* 对新生代进行GC时, 避免把整个老年代的对象都加入GC Roots的扫描范围, 在新生代建立了Remembered Set(记忆集)结构
* 记忆集记录了从非收集区域(老年代)指向收集区域(新生代)的指针集合
  * 不需要精准的指向引用对象，只需要确定内存块的位置，扫描时将对应块的老年代对象加入GC Roots检查中就可以了; 这称为卡精度
  * 其他可选的还有: 对象精度(精确指向引用对象); 字长(即虚拟机的位数,32/64)精度(表示该字包含引用指针)
* 使用卡精度的实现方式可以称为卡表
  * 一块内存的大小为512B, 即卡页=512B
  * Hotspot的实现方式是一个字节数组,  所以标记这一块内存存在跨代引用就是 CARD_TABLE[addr >> 9]=1
    * 值为1称为这个元素变脏
    * 为啥使用byte[], 而不是按位? 主要是考虑硬件是按字节寻址的, 不能直接存bit, 如果一个byte表示8块则还需要几条shift+mask指令来计算
* 其实所有支持部分区域收集的收集器都会遇到跨区域引用的问题

## 何时维护卡表--------写屏障

* 逻辑上来说, 当出现老年代对象引用新生代对象的时候就应该把卡表变脏, 即赋值那一刻就应该变脏
* 如果是虚拟机解释执行, 那么虚拟机可以负责这个变脏的操作
* 如果是编译执行, 就需要在机器码层面完成, 这里就需要用到写屏障技术
  * **Warning: 这里的屏障和内存屏障完全不是一个概念, 内存屏障是CPU指令级别保证多线程访问下内存正确性和有序性的技术**
  * 写屏障可以看作虚拟机级别对引用类型字段赋值操作的AOP切面, 执行时产生一个Around, 在赋值前后都可以执行操作, 被称为写前/后屏障
* 卡表维护的伪共享问题
  * CPU的缓存是以行为单位的, 我们假设其为64B
  * 如果两个线程都负责把卡表变脏, 这两个对象的内存位置相距 < 512B*64, 即小于32KB
  * 卡表中这两个元素的位置间隔就会<64, 也就有可能被加入到同一个缓存行内
  * 多个线程对CPU缓存内容进行修改, 就会彼此影响, 相互让对方的缓存失效, 写回主存, 重新加载
* 解决伪共享问题:
  * -XX:UseCondCardMark来开启给卡表变脏前判断是否已经变脏, 但是这又带来了判断的开支和CPU分支预测失败的开支

## 并发可达性分析-------三色标记法

### 三色

* 黑色: 已经被访问过, 确定这个对象会存活下来; 黑色对象引用的不能是白色对象
* 灰色: 被黑色对象引用, 但是收集器还没有扫描过它的引用
* 白色: 没有被收集器检查过, 如果可达性分析结束还是白色, 说明对象将被回收

### 实现

* 并发可达性分析开始时, 仅有GC Roots为灰色, 其他为白色
* 每轮都扫描灰色对象, 将其关联的白色对象标记为灰色, 将扫描过的灰色对象标记为黑色
* 完成扫描后白色对象即不能通过GC Roots到达的对象

### 问题

* 并发可达性分析阶段并不要求STW, 赋值器(用户线程)可能改变引用关系
  * 如果删除一个黑色对象到灰色对象的引用, 则可能会导致这个灰色对象及其引用对象没有被回收, 这种问题可以忍受
  * 如果增加一个黑色对象到白色对象的引用, 则这个白色对象最终不会变黑, 被误回收, 这种问题无法接受

### 问题分析及解决方案

* Wilson论证了只有以下两个条件同时满足才会将应该是黑色的对象误标记为白色
  * 赋值器插入了一条或多条黑色对象到白色对象的新引用
  * 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用 (即没有灰色对象直接/间接的引用这个白色对象)
* 无论增量更新, 原始快照法, 都需要stw; CMS收集器的最终重新标记阶段就是做这个事情

#### 增量更新

* 破坏第一个条件: 当插入黑色对象到白色对象的引用时记录这个黑色对象, 并发扫描结束时, 以这些黑色对象为根, 重新扫一次
  * 如何确定把白色对象赋值给了黑色对象? 又是前面提到的写屏障了
  * CMS采用这种方案

#### 原始快照

* 破坏第二个条件: 当灰色对象删除指向白色对象的引用时, 就记录下来, 并发标记结束之后, 再按照这些灰色对象为根, 重新扫描一次(自然是按照引用关系还存在的样子来扫描)
  * 如何实现记录引用关系被删除, 自然还是写屏障
  * G1, ZGC, Shenandoal都采用这种方案