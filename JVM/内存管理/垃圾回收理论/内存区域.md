# 内存区域

## PC Register

* 程序计数器可以看作指向当前正在运行的字节码行号的指示器, 如果运行的时本地方法, 则是空的
* 它保证了线程切换之后能恢复到正确的位置进行运行
  * 和操作系统课的程序计数器一样在发生中断/程序切换时的作用一样
* 它属于每一个线程私有的内存, 线程间互不影响
* 此区域没有规定OutOfMemory异常

## 虚拟机栈

* 每个方法被运行的时候都会创建一个栈桢存储局部变量, 操作数栈, 动态连接方法出口信息, 方法执行完毕时出栈
  * 局部变量表存放了编译期可知的基础类型和对象引用
* 如果栈的深度超过虚拟机允许的深度, 则抛出StackOverflowError
* 如果栈的内存无法扩展, 抛出OutOfMemoryError

## 本地方法栈

* 类似于虚拟机栈, 服务于执行本地方法的执行
* JVM标准没有强制规定其实现方式, 所以不同虚拟机实现比较自由
* 同样可能抛出StackOverflowError, OutOfMemoryError

## Java堆

* 所有线程共享, jvm管理最大的内存区域, 几乎所有对象实例都在这个区域进行内存分配.
* JVM堆被垃圾自动回收器管理
  * 在G1出现以前, 堆的内存划分都基于经典的分代理论进行设计

## 方法区

* 方法区也属于线程共享的区域, 用于存储已经被虚拟机加载的类, 常量, 静态变了, 即时编译之后的代码缓存信息等
* JDK8以前, HotSpot对方法区的实现方式是永久代, JDK7在Oracle收购JRockit之后吸收其方案, 改为元数据区
  * 方法区是JVM标准定义的内存区域, 永久代和元数据区是hotspot的实现方案
  * 字符串常量池, 静态变量等移动到堆中
  * JDK7的类型信息还在永久代, JDK8彻底改到元空间中

### 运行时常量池

* 属于方法区的一部分, class文件中存在常量池表, 存放了编译期生成的各种字面量和符号引用, 类加载之后放到常量池

## 直接内存

* 直接内存并不属于虚拟机运行时数据区, 不在JVM规范中定义
* JDK1.4引入NIO的概念之后, 使用Channel和Buffer可以直接用Native函数库在堆外分配内存, 然后使用DirectBuffer进行访问, 避免在堆内存和操作系统内存中来回复制


