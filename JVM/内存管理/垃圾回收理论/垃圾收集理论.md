# 垃圾收集器

## 哪些区域需要回收内存?

* 本地方法栈/虚拟机栈/程序计数器随着运行结束就能自动回收, 不需要垃圾回收器参与
* 堆区/方法区需要内存回收

## 如何判断对象已死?

### 引用计数法

* 在对象上加一个引用计数器, 每有一个地方引用它就自增一次, 引用失效时减一
* 如果引用数变成0就说明对象应当被回收
* 这个算法看似简单, 但是需要很多额外处理才能保证可用, 比如循环引用问题

### 可达性分析

*  以GC Root为起点, 如果没有引用路径可以到达一个对象, 那么它是可回收的

#### GC Root有哪些

* 虚拟机栈中引用的对象
* 本地方法栈引用的对象
* 方法区静态属性引用的对象
* 方法区常量引用的对象
* 虚拟机内部的引用, 常驻异常对象等
* 被synchronized同步锁持有的对象
* 反应JVM内部情况的Bean, 如JMX Bean, JVMTI中注册的回调, 本地代码缓存等

#### 引用类型

* 强引用: 最常见的对象引用, 如 Object o = new Object(); 任何情况下, 只要GCRoot到这个对象的强引用还存在,  对象就不会被回收
* 软引用: 软引用用来描述一些有用, 但是非必须的对象, 在系统将要发生内存溢出时, 这些对象将会被列入回收范围进行第二次回收, 如果这次回收之后还是没有足够的空间, 系统将会抛出内存溢出异常
* 弱引用: 弱引用也用来描述一些非必须对象, 强度比软引用更弱, 这些对象只能存活到下一次GC, 无论内存是否足够, 这些对象都会被回收
* 虚引用: 最弱的引用关系, 设置虚引用的目的是为了在这个对象被回收时收到一条通知

#### 对象的逃生之路----finalize方法的作用

* 在对象被GC时, 如果发现重写了finalize方法, 并且没有被执行过, 将会把finalize方法的调用加入到F-Queue任务队列
  * 仅保证调用, 不保证会等待它运行结束, 避免因为执行慢影响GC
* 如果finalize执行过程中, 这个对象变为可以从GC Root强/软引用可达, 那么它将不会被回收
* 如果对象再次变为可回收状态, 它的finalize方法不会被再次调用, 而是直接被回收


## 垃圾回收算法(理论)

### 分代回收理论

#### 两个假说和一个推论

* 弱分代假说
  * 大多数对象都是朝生夕死的
* 强分代假说
  * 熬过越多次回收的对象就越难以消亡
* 推论: 跨代引用假说
  * 夸带引用相对于同代引用的数量极少

#### 分代GC

* 至少将堆内存划分为新生代和老年代区域
  * 通过记忆集标识老年代哪一块区域存在跨代引用, Young GC时这一块区域的老年代对象也视为GC Roots
* Young GC/MinorGC: 仅回收新生代的垃圾
* Major GC/Old GC: 仅回收老年代的垃圾; 只有CMS会单独收集老年代
* Mixed GC: 收集整个新生代和部分老年代的垃圾; 只有G1有这种行为
* Full GC: 全堆收集

### 标记清除算法

* 标记所有存活/需要被清除的对象, 然后清除需要清理的对象;
* 执行效率不稳定: 对象数量大时, 需要进行大量标记和清除工作
* 内存碎片化: 标记清除之后会产生大量的不连续内存, 这些空间可能无法被利用

### 标记复制算法

* 将内存划分为相同的两块, 一块进行对象分配, 一块给GC时使用
* 垃圾清理时先标记存活对象, 然后将存活的对象都复制到备用的内存, 切换两块内存的角色
* 优点: 不会产生内存碎片, 缺点: 降低空间利用率

#### 案例: Serial, Parnew等新生代回收器的新生代内存布局策略

* 根据研究: 98%的对象无法存活超过一次GC
* 将新生代分为两块相等的Suvivor区和Eden区, 默认大小比例为1:1:8
  * 两个enden区上的对象大部分都是朝生夕灭, 按照标记复制算法进行清理
  * suvivor空间不足时, eden区存活的对象将会直接进老年代

### 标记整理算法

* 既不想有内存空间损耗又不想有内存碎片, 就需要进行对象位置挪动
  * 和稀泥方案: 内存碎片不多的时候使用标记清除, 太多了再整理, CMS就是这样的
