# 对象

## 创建对象

* 类被加载后就可以确定创建一个对象需要分配多少内存
* 通过指针碰撞法/空闲列表法确定一个内存区域可以分配给这个对象使用
  * 如果垃圾回收器支持压缩整理, 则可以采用指针碰撞法
    * 指针碰撞法: 在规整的内存区域上, 空闲内存和已使用内存有一个明确的边界, 移动这个指针偏移需要的内存大小的距离即可; 注意操作必须要CAS, 防止并发问题
  * 如果不支持标记整理, 比如CMS, 只支持标记清除, 则只能用空闲列表法
    * 空闲列表法: 维护空闲内存段的链表信息, 找到一个可以分配给新对象的区域给新对象分配内存
  * TLAB: 线程提前申请一块堆内存作为内存分配缓冲区, 在这个区域内只有一个线程进行操作, 就不需要CAS了
* 内存分配完之后, 将对象除对象头以外其他内存空间都初始化为0
  * TLAB可以提前将分配到的空间都初始化为0
* 初始化对象头, 如是哪个类的实例, GC年龄等信息
* 调用构造函数, 初始化属性

## 对象的内存布局

* 对象的内存区域可以分为三部分: 头, 实例数据, 对齐填充

### 对象头

* 对象头包括两类信息: 对象运行时数据, 类型指针

#### 对象运行时数据

* 运行时数据包括hash码, GC年龄, 锁状态标志, 持有锁的线程id, 偏向线程id, 偏向时间戳等, 被称为markword; 长度等于虚拟机的位数
  * 实际上这些信息的总长度超出了32/64bit能记录的范围, markword被设计成了可以动态定义的数据结构, 通过不同的标志位表示其存储的内容含义

| 标志位 | 状态     | 存储内容                   |
| ------ | -------- | -------------------------- |
| 00     | 轻量级锁 | 指向锁记录的指针           |
| 01     | 无锁     | 对象的Hash码, 对象年龄分代 |
| 10     | 重量级锁 | 指向重量级锁的指针         |
| 11     | GC标记   | 空, 不需要记录信息         |

* 关于synchronized的锁升级, 查看文档[锁优化]()

#### 类型指针

* 指向该对象类的类元数据, 长度等于虚拟机位数, 64位虚拟机开启压缩指针后长度为32位
* 并不是所有对象都需要保留类型指针, 一些类型是可以固定且推导类型的对象就不会保留类型指针, 尤其是JVM自身使用的元数据对象
* 如果jvm使用句柄方式进行对象访问, 对象头上也没有类型指针
* 数组对象还需要32b的长度表示数组长度

## 对象的访问方法


### 句柄

* 对象引用指向的并不是对象的实例, 而是句柄池中的对象句柄信息
* 句柄有两个信息: 指向对象实例的指针, 指向对象类型的指针
  * 所以可以看出, 这种方式访问对象, 对象头上不需要有类型指针
* hotspot大多不使用句柄, 使用Shenandoah垃圾收集器就会使用句柄方式访问对象

### 直接指针

* 对象引用指向的对象实例数据, 同时对象头上有一个类型指针指向方法区的对象类型数据
* hotspot主要使用直接指针访问


