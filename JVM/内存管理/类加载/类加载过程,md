# 类加载

## 类的生命周期

* 加载
* 连接
  * 验证
  * 准备
  * 解析
* 初始化
* 使用
* 卸载


## 加载的时机: JVM规范了6种情况必须对类进行初始化

* 遇到 new(创建对象), getstatic(读取静态变量), putstatic(修改静态变量), invokestatic(调用静态方法)这四条指令
* 使用java.lang.reflect对类型进行反射调用, 如果类还没有被初始化, 需要立即初始化
* 初始化一个类时, 如果它的父类还没有初始化, 应当初始化它的父类
* 虚拟机启动时, 需要执行主类会被虚拟机先初始化
* jdk7的动态语言支持: java.lang.method.methodHandle如果解析为REF_getStatic/REF_putStatis/REF_invokeStatic/REF_newInvokeSpecial四种方法句柄, 并且对应的类没有初始化, 就需要先初始化这个类
* java8的default方法: 如果含有default方法的实现类发生初始化, 应该先初始化这个接口

## 类加载的过程

### 加载

* 通过类的全名获取类的二进制字节流
* 将这个字节流转化为方法区的运行时数据结构
* 由于没有规定要从哪里获取二进制流, 所以可以有很多方式
  * 从压缩包, 如jar, war
  * 从网络: applet技术
  * 运行时生成: proxy
  * 从其他文件生成: jsp
  * 从数据库: SAP的netweaver  
  * 加密文件中获取
  * ...

### 验证

* 文件格式校验, 如魔数, 版本号, 不支持的类型
* 元数据验证, 主要是语义校验: 父类, 继承权限, 方法覆盖权限, 是否实现了全部要求实现的方法等
* 字节码校验
  * 保证指令和操作数类型匹配
  * 保证指令跳转不会跳出方法外
  * 类型转换有效性, 比如不能把父类类型赋值给子类
* 符号引用检验: 检查依赖的外部资源
  * 检查描述符是否能找到对应的类
  * 检查指定类是否有符合访问的方法, 属性
  * 检查访问的方法, 属性是否有权限访问

### 准备

* 正式在方法区为变量(静态变量)分配内存, 设置初始值

### 解析

* 解析阶段是虚拟机将常量池的符号引用(如Ljava/lang/Integer)替换为直接引用(指针)的过程

### 初始化

* 执行`<cinit>`方法, 这个方法是编译器生成的, 包含所有类变量赋值语句和static代码块