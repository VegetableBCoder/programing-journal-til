# Java内存模型

* 内存模型的作用是定义程序中各种变量的访问规则, 即虚拟机把变量值存储到内存和从内存取出对象的操作细节.
  * 包括实例字段, 静态字段, 构成数组的元素
  * 这里的变量不包括线程私有的局部变量和方法参数, 因为它们是线程私有的
  * 如果局部变量是引用类型, 则复制的是引用类型(如数组), 对象的内容还是在主存里, 等要访问属性时会复制属性
* Java线程模型没有限制字节码执行引擎使用寄存器, CPU高速缓存来和内存交互; 也没有限制JIT是否跳转代码执行顺序(乱序执行)

## 主存与工作内存

* Java内存模型规定所有变量都存放在主存中, 每个线程还可以拥有自己的工作内存, 用于存放线程使用的变量的副本
  * 线程访问一个10MB的巨大对象, 会完全复制它的内容吗? 答案是不会, 只会复制线程访问到的某些字段, 而不是复制整个对象
  * 如果访问的是一个很大的数组, 
* 线程对变量的修改都必须在在工作内存中, 不能直接读写住内存的数据
* 不同线程之间不能相互访问工作内存
<br/>
* 这里的内存模型和内存分代/垃圾回收器的内存布局没有任何关系, 最多可以说主存是堆内存
* 工作内存对应于内存, 在不同环境下工作内存可能有不同形式, JVM/CPU/操作系统可能使用寄存器/高速缓存来作为工作内存

### 内存间交互: 内存模型定义的8种原子操作

| 操作   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| lock   | 将一个主存变量标记为线程独占                                 |
| unlock | 释放被线程独占的变量 允许其他线程独占                        |
| read   | 将变量从主存传输到工作内存, 以便被load使用                   |
| load   | 将read得到的变量放入工作内存的副本中                         |
| use    | 将工作内存中使用的变量值传给字节码执行引擎                   |
| assign | 在工作内存中使用, 从执行引擎接受一个值, 赋值给工作内存的变量 |
| store  | 作用于工作内存变量, 将变量值传输到主存中, 方便write使用      |
| write  | 将assign传输到主存的值放入主存中                             |

### JSR 133

* 去掉了具体的 load/store/use/assign 等“流水线式”模型; 这个改动把内存访问协议从实现级改为语义级
  * 允许虚拟机根据CPU架构映射到不同的内存屏障
  * JIT可以自由指令重排, 只要语义一致即可

### 访问规则

* 不允许read/load 或者store/write 单独出现, 只能成对出现
  * 即不允许从主存读了数据, 工作内存不接受; 主存发起回写, 但是主存不接受
* 不允许一个线程丢弃最近的assign操作
  * 修改了变量值就必须将其同步回主存
* 不允许线程在没有修改值的情况下将变量从工作内存同步回主存
* 新的变量只能在主存中诞生
  * 变量必须read load 才能use
* 一个变量只能由一个线程lock, 不能多个线程一起lock
* 如果一个变量被lock, 将会清空工作内存中此变量的值, 执行引擎中使用这个变量值前, 必须重新执行load或assign操作以初始化变量的值
* 不允许unlock未被锁定的对象
* 执行unlock前必须先把工作内存中的值store+write同步回主存

#### volatile关键字

* 将值写入主存的时候会发出 StoreStore+StoreLoad内存屏障, 通过缓存一致性协议, 让其他CPU核中的缓存失效
* 读取时会有LoadLoad+LoadStore内存屏障, 确保读取的变量一定和主存一致
* 为什么volatile变量多线程自增结果会不对? 不提供互斥, 允许多个线程一起堆一个变量 读-改-写; 多个线程的写发生相互覆盖就会出现问题


