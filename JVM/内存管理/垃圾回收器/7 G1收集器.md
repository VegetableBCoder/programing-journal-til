# G1收集器

* JDK7开始出现, JDK9 起作为服务端默认收集器
* 不再按照分代方式进行回收, 而是将堆内存分成多个region, 优先回收垃圾多的region

## 概要

* 仍然保留新生代, 老年代的概念, 但是不再固定, 而是一系列region的动态集合, 仅在逻辑上连续

## 内存规划

* 将内存划分为多个大小相同的region, 每个region都可以根据需要, 成为Eden/Survivor/老年代空间的一部分
* 大对象(大于一个region的一半大小)处于特殊的Humongous区域, 一个大对象处于连续的多个region上; 这些region视为老年代

## GC执行过程

* 初始标记 STW
  * 需要stw, 但是特别短, 仅标记一下GC Roots能直接关联的对象
* 并发标记 不需要STW
  * 三色标记法的可达性分析和原始快照记录被删除的灰色对象和白色对象的引用
* 最终标记 STW
  * stw做一下原始快照留下的少量记录
* 筛选回收 STW
  * 对需要回收的region的回收成本, 价值进行排序
  * 按照用户期望的停顿时间制定回收计划, 选择任意多个region构成回收集
  * 将region里面存活的对象复制到新region, 然后清理旧Region
    * 这里从region的局部看是标记复制算法, 从堆的整体上是标记-整理算法

## 与CMS优缺点对比

* G1诞生以来目标就是取代CMS

* G1在面对大堆时延迟可控
* G1不会产生内存碎片, 有利于程序长时间运行; CMS会产生碎片, 可能并发失败进行FullGC
* G1由于分region的问题, 维护跨代引用的一份卡表变成每个region都要一份的跨region引用卡表, 明显增加了额外的内存开销, 最大可达堆内存的20%
* CPU开销
  * CMS G1都需要使用写后屏障维护卡表, 但是G1的卡表更复杂, 消耗更大
  * G1需要使用写前屏障维护原始快照, CMS需要使用写后屏障维护增量引用信息;
* G1使用的原始快照法扫描时相对于CMS增量更新法的消耗更少; 增量更新/最终标记的阶段 G1会优于CMS
* 回收/清除阶段: CMS和用户线程并行, G1需要STW但停顿可控, 各有优劣

## G1的停顿限制和Full GC

* 如果用户的停顿要求过于苛刻, G1在制定回收计划时, 可能每次进行很少一部分region的内存回收
* 长期的回收空间<分配空间, 必定会出现没有空间可以分配给新对象, 这时就会触发FullGC
* 触发FullGC可能会产生很长的GC

## G1在实现时面对的问题

* G1从论文到上桌用了快10年, 中间遇到课跟多的问题, 简单列举一些

### GC时跨Region对象引用问题如何解决?

* 按照分代回收的记忆集思路, 可以通过卡表维护老年代指向新生代的跨代引用
* G1维护跨region的对象引用也是每个region一个卡表, 通过写后屏障维护跨region的引用关系
* 根据经验: G1需要使用相当于堆内存10%-20%的额外内存维护卡表
* G1的全局卡表记录了哪些卡包含跨region引用; 局部卡表是一个Hash表:
  * key是别的region的起始地址
  * value是一个集合: 内容是这个region的哪些卡页引用了当前region的对象

### 并发标记阶段如何保证GC线程和用户线程不干扰?

* 在并发可达性分析的介绍中已经提到了增量更新和原始快照法
  * G1采用原始快照法, 所以需要用写前屏障维护引用被移除的信息
  * 使用原始快照法, 忽略了在并发标记期间产生的对象, 这些对象也应当标记为存活
* 垃圾收集器对用户线程的影响还体现在region内用户线程新创建对象的影响上, 这些新创建的对象, G1默认他们是存活对象, 不在回收范围
  * 所以G1设置了TAMS指针. 把region中一部分区域划分出来用来存放GC标记期间创建的对象

### 停顿预测模型怎么建立?

* G1采用衰减均值法进行预测
  * 在垃圾回收的过程中, G1记录每个region的回收耗时, 脏卡数量, 等各个步骤的成本, 分析得出平均值, 标准差, 置信度信息
    * 之所以是衰减平均值是因为统计数据受新数据的影响更多
* 有了预测方法就可以按照用户预期停顿规划清理哪些region获得最高收益