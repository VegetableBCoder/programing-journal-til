# ZGC

* Oracle于JDK11中发布, JDK15正式转正
* 设计目标与Shenandoah相同, 都是在任意大小的堆下, 尽可能不影响吞吐量的情况下, 控制垃圾收集的延迟
* ZGC要解决的一个重要问题就是实现G1原本计划实现的任务: 并发清理过程不再需要STW, 可以与用户线程并行运行
* 在吞吐量上接近以吞吐量控制为要求的paralled scavenge, 在延迟上超越 G1, Shenandoah;
* 某种程度上可以说ZGC就是免费版的C4收集器
* ZGC由于使用染色指针初期最大堆支持为4TB, JDK15开始支持到16TB
* 这份笔记仅适用于JDK21-的ZGC, 因为JDK21中ZGC又引入了分代收集

## 内存布局

* 与G1一样将内存划分为多个region, 但是region的大小可以不同
  * 小型region容量固定为2MB; 放置<256KB的小对象
  * 中型Region容量固定为32MB; 存放256KB-4MB的对象
  * 大型对象的容量为2MB的整数倍, 用于存放4MB或以上的对象; 一个大型region只会存在一个大对象
  * 大型对象因为复制成本高, 所以大型Region不会重分配

## ZGC执行过程

* ZGC扫描时会扫描所有区域再制定回收计划, 所以不需要像G1那样维护记忆集(卡表)
  * JDK21+ ZGC又支持分代收集了, 这样又得维护记忆集, 卡表怎么维护的还没研究
  

* 初始标记 STW
  * GC Roots直接关联的对象
* 并发标记 大部分时间不STW, 只有结束收尾时需要stw
  * 三色标记法进行可达性分析
  * 并发标记完成需要使用原始快照防止误标记有效对象, 此时需要短暂stw
* 并发预备重分配
  * 制定回收计划, 确定回收哪些region, 将这些region组成重分配集
* 并发重分配
  * 把重分配集的存活对象复制到新的region上, 维护一个转发表, 记录旧对象和新对象的转发关系
  * 由于染色指针的支持, ZGC可以通过引用就知道对象是否处于重分配集中
    * 如果用户线程访问这个对象, 会被读屏障截获, 然后给根据转发表定位到新的新复制的对象上
    * 访问新对象的同时, 这个指针将会"自愈", 变为指向新对象
    * 这样的好处就是相比Shenandoah每次都需要判断, 完成引用更新前都需要转发, ZGC只有GC之后第一次访问会多一次转发, 后面都不需要转发
  * 还有一个好处就是不像Shenandoah那样得等到引用更新完毕才能释放旧region的空间, ZGC在复制完成之后就能释放region
    * 当然, 转发表得保留到重映射完成, 否则就无法定位了
* 并发重映射
  * 修改所有指向重分配集中对象的引用的地址, 改为指向复制以后的对象的地址
    * 这一步并非很迫切的任务, 因为染色指针是可以自愈的
    * 这一步的工作也可以在下一次GC的并发可达性分析的去做, 这样就省了一次对象图的遍历时间

## 染色指针

* 64位操作系统的数据地址64位最多支持164EB内存, 但是AMD64架构只支持52位(4PB)寻址, 64位linux支持46位(64TB)物理内存寻址, 64位windows甚至只支持44位(16TB)
* 尽管linux下高18位不能用来寻址, 但是46位指针也足够给大型Java应用使用了, ZGC在剩下的46位可用位上提取4位作为标记位, 剩下42位(4TB)用来寻址, 这就解释了为啥ZGC最大只支持4TB的堆
  * 为啥不从不能使用高18位来存放标记信息? CPU规定的高位必须等于有效位的扩展符号位, MMU会校验的!!!

### 早期标记位设计 4位

* [0-41]位实际地址 42: marked0 43: marked1 44: Remapped 45: Finalizable 46-63: CPU要求必须与第45位一致

#### 标记含义

* marked0和marked1: 标记对象存活, 在对象被判断为存活时会在某一位上标记为1, 在多轮回收周期中交替使用
  * 如本轮GC使用mark0: mark0=0 说明没有被标记位存活, mark0=1则被标记为存活, mark1=0说明是上一轮GC之后到本轮GC之间生成的对象 mark1=1则是上一轮GC存活的对象
* remapped: 对象是否被在重分配集的标记, 核心作用就是仅通过指针就能判断引用指向的是重分配前还是重分配后的地址, 不必要每次都走转发表检查
  * 并发标记阶段, remapped标记会被统一清除为0
    * 如果其他对象持有的某个对象的引用(指针)没有自愈或者重映射, 这里会完成引用地址的重映射, 替换为上一次复制之后对象的地址
  * 当一个对象处于重分配集中, 通过其他某个对象对它的访问, 会将持有这个对象引用的remapped变为1
    * 如果访问旧地址, 通过指针自愈就能把引用变为新地址
* finalizable: 对象需要被回收, 但是尚未进行finalize方法调用, 暂时不能回收;  支持并发回收过程中执行finalize
  * finalizable标记不能保证finalize只会调用一次, 这个保证是jvm层面对每个对象都有终接器(finalize)调用状态标记
    * 未处理
    * 已注册(加入队列)
    * 已调用
