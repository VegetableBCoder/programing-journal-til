# Shenandoah收集器

* JDK12中开始出现
* RedHat开发的收集器, 从未在Oracle的商用和OpenJDK中搭载过
* 以地延迟为目标的收集器, 相比与CMS, 不产生内存碎片, 有利于程序长期运行, 相比于G1在清理阶段可以和用户线程并行运行
* Shenandoah默认不在逻辑上分代
* 在任意大堆上实现低延迟

## 执行过程

* 初始标记 STW
  * 与G1一样, 标记与GCRoots直接关联的对象;
  * 停顿时间与堆大小无关, 与GC Roots数量相关
* 并发标记 不需要STW
  * 与G1一样, 遍历对象图, 找出可达对象
  * 与用户线程并行, 耗时取决于堆中的存活对象数量和对象图的复杂度
* 最终标记 STW
  * 与G1一样使用原始快照法处理
  * 统计各region的回收价值, 构建回收集
* 并发清理 非STW
  * 清理对象全部死亡的region
* 并发回收 非STW
  * 将region中存活对象复制到其他未被使用的region中
    * 看似简单的复制, 实际上要考虑与用户线程的并行, Shenandoah调整了对象访问方式, 用了转发指针(Brooks Pointer)的方式
  * 将复制前的旧对象的Brooks Pointer指向新对象, 复制后的新对象的Brooks Pointer指向自己
* 初始引用更新 STW, 但是特别短
  * 建立一个线程集合点, 确认所有GC线程都完成了复制任务
* 并发引用更新 非STW
  * 沿着内存地址顺序遍历堆中对象的引用(可以参考Shenandoah的连接矩阵确认region中是否引用了被清理区域的对象), 更新它们的引用对象地址为复制后的新对象地址
* 最终引用更新 STW, 但是特别短, 与GC Roots数量有关
  * 显然, 除了堆内存, 虚拟机栈, 方法区等其他GC Roots中的引用也需要更新为新的对象地址
* 并发清理
  * 经过引用调整之后这些被复制的Region就都变为空的了, 清理这些region即可

## 解决并发回收过程中用户线程和对象复制的干扰问题的两种方案

### 内存保护陷阱

* 在被移动的对象上设置内存保护陷阱, 注册异常处理器(类似于HotSpot线程判断当前是否在GC的检测方式)
* 访问被复制的对象时, 触发内存保护陷阱, 通过异常处理器把访问转发到新的内存地址上
* 这种方式在test指令触发异常需要进行内核态和用户态切换

#### 内核态与用户态切换

* 只有内核态才能安全修改页表, 分配物理页, 恢复异常状态
* 发生page fault/protecttion fault时的动作:
  * 保存用户态寄存器和状态信息 (中断现场保存)
  * 根据中断向量表跳转到内核态的异常跳转函数
  * 内核检查异常原因: 缺页? 访问地址非法? 访问权限错误?
  * 内核执行下一步操作: 缺页就调页(可能阻塞进程) 权限错误就给进程发送SIGSEGV信号
  * 回到用户态, 恢复现场, 继续执行
* 对象定位是非常频繁的, 即使是在并发回收这个阶段也会后非常多的对象访问操作, 频繁的内核态用户态切换无法接受
* GC信号的检测使用这种方式是因为绝大部分时间不在GC test指令都不会触发异常, 一个线程遇到异常之后就知道自己应该准备在下一个安全点停下来, 影响不大

### 转发指针 ----- Brooks Pointer

* 在对象头上增加转发指针, 对象没有被移动时, 指针指向自己
* 对象移动时旧对象头上的转发指针指向新的对象
* 还需要保证对象复制过程中就对象不会被写入数据
* 这种方式虽然多了一次转发过程(一条汇编指令), 非特殊场景下相比于内核保护陷阱的开销可以接受
  * 注意: CPU密集型场景下间接寻址导致的性能损耗可达5%-10%

## G1每个region一个卡表的替代方案------连接矩阵

* G1的卡表是卡粒度的, 一个卡页为512B或1KB, 而一个Region的大小为1-32MB, 所以Shenandoah只精确到region级别的连接矩阵需要的空间小很多
* 矩阵的M行N列表示: 第M个region是否存在引用第N个region的跨region引用