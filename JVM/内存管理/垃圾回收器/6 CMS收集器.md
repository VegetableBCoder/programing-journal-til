# CMS收集器

## 概要

* 收集区域: 老年代
* 算法: 标记清除
* STW: 需要STW, 但不是全程STW
* 并发执行: 分阶段, 部分阶段多线程
* 设计目标: 低停顿
* JDK15移除, 彻底退休

## 执行过程

* 初始标记, 需要STW
  * 找出GC Roots; 参考[HotSpot垃圾回收算法实现](../垃圾回收理论/HotSpot垃圾回收算法实现.md)的GC Root部分
* 并发标记, 不需要STW
  * 使用三色标记法分析哪些对象是需要清除的; 参考[HotSpot垃圾回收算法实现](../垃圾回收理论/HotSpot垃圾回收算法实现.md)的三色标记法部分
* 重新标记, 需要STW
  * 使用增量更新法处理并发标记期间增加的黑色对象到白色对象引用; 参考[HotSpot垃圾回收算法实现](../垃圾回收理论/HotSpot垃圾回收算法实现.md)的三色标记法问题和处理部分
* 并发清除, 不需要STW
  * 清除已经被标记为死亡的对象

## 特点

* 低停顿; 仅有初始标记和重新标记阶段需要STW
* CPU资源敏感: 并发标记和并发清除阶段都和用户线程一起运行, 可能会与用户线程争抢CPU资源
  * 默认使用的CPU核数是 (CPU核数+3)/4, 不足4核的影响可能比较大
* GC时用户线程的执行可能忽然就变慢了
* 由于GC执行时程序还在运行, 就不能等老年代满了再GC, 需要预留一部分空间给GC过程中用户线程使用
  * 这个触发GC的阈值默认值在jdk 6+之后为92%

## 并发失败

* 由于CMS没有进行内存整理, 可能可用空间碎片化到不足以找到连续空间给新迁入老年代的对象分配内存, 这样就会触发一次并发失败
* 在这种情况下会使用Serial Old,完全STW执行一次FullGC
  * 这样可能停顿的时间可能长到用户无法接受
  * 所以生产环境谨慎调整触发GC的内存占用阈值, 避免太大而出现并发失败