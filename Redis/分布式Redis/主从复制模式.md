# 复制模式

* 通过slaveof命令, 将节点变为其他节点的从节点, 保持数据一致

## 旧版本复制 ver<2.8

### 同步

* 从服务器向主服务器发送sync命令
* 主服务器执行BGSAVE命令, 生成RDB文件, 使用缓冲区记录从此开始的全部命令
* 将RDB文件发给从节点, 从节点加载数据库
* 主节点将缓冲区的命令发送给从节点, 从节点执行命令

### 传播

* 首次完成状态同步之后主服务器将自己执行的写命令都同步给从节点

## 新版复制 ver>=2.8

* 解决的问题是从节点断线后从头复制RDB文件的效率问题
  * 主节点要起子进程做BGSAVE 还要占用网络资源发给从节点

### PSYNC

* 完整同步的流程和旧版本的sync一致
* 部分同步则用于断线重连, 优先根据复制偏移量判断能否通过命令完成重连后的数据同步, 无法完成再通过完整同步处理
  * 复制偏移量在主从节点上都有记录, 主节点向缓冲区发送N个字节就加N, 从节点收到N个字节就+N
  * 如果主从节点状态一致, 那么主从节点的偏移量是一致的, 不一致也说明从节点还需要执行主节点同步的命令
  * 主节点维护一个1MB的积压缓冲区, 按FIFO规则进行淘汰
  * 如果断线之后差值<1MB, 说明需要执行的命令还在积压缓冲区, 从积压缓冲区进行同步就可以了, 如果>1MB则说明积压缓冲区的命令无法完成同步, 需要执行完整复制
    * 从服务器启动后向主节点发送psync命令和自己的复制偏移量
    * 主节点判断断开之后的首条命令是否在积压缓冲区
    * 服务器返回FULLSYNC <runid> <offset>则需要全量同步, 返回continue则直接等主服务器将缺失的命令发过来即可

## 心跳和命令丢失检测

* 从节点每秒1次向主节点发送 REPLCONF ACK <replication_offset>
* 如果因某种原因主节点发送给从节点的命令丢失, 主节点可以通过REPLCOF ACK发现
* 主节点根据从节点发送的偏移量从积压缓冲去找到丢失命令开始的第一条数据, 发送给客户端
  * 旧版本没有REPLCONF ACK和积压缓冲区, 丢了没法发现