# 集群模式

* 集群模式是redis的分布式数据库方案, 通过分片进行数据共享, 提供复制和故障转移能力
* 集群模式只能使用db 0

## 节点

* 集群建立前, 节点都是独立的, 需要通过CLUSTER MEET来进行我手
  * > CLUSTER MEET `<ip> <port>`
* 节点使用clusterNode保存当前节点信息, 使用clusterState记录当前节点视角下其他节点的状态
* 通过CLUSTER MEET认识的新节点会由Gossip协议将转发给集群内的其他节点, 这样所有节点就会都认识新节点

## 槽分配

* 将库分为16384(2^14)个槽, 每个节点负责处理其中的一部分
  * 所有节点都有槽在处理时集群状态正常, 否则集群处于下线状态
* 节点的clusterNode结构记录了自己负责的槽
* 节点会将自己负责的clusterNode广播给集群内的其他节点, 其他节点将这些信息记录到clusterState结构中
* 在集群中执行命令操作key时, 会先redirect到key所在的节点
  * key属于哪个槽的计算是先通过CRC16再&16384取余, 得到槽号
  * 通过clusterState获取所在的节点, 判断是否是当前节点, 如果不是, 返回MOVED错误
  * 客户端重定向到新的节点

## 重新分片

* 将槽重新分给其他节点时, 可能需要做数据迁移由redis-trib完成
* 向源节点发送CLUSTER SETSLOT `<SLOT>` IMPORTING `<source_id>`, 让源节点准备好要迁移的数据
* 向源节点发送CLUSTER SETSLOT `<slot>` MIGRATING `<target_id>`, 让源节点准备好将属于该slot的键值对迁移到指定节点
* 向源节点发送CLUSTER SETSLOT `<slot>` GETkeySINSLOT `<slot>` `<count>` 从源节点的槽取出最多count条key
* 向源节点发送MIGRATE `<TARGET_IP>` `<target_port>` `<key_name>` 0 `<timeout>`, 将上一步获取的全部key迁移到新的节点
* 重复上两个步骤, 迁移所有key

### ASK错误

* 在重新分片期间, 可能出现迁移的源节点没有找到这条数据, 需要去新节点的槽寻找这条数据
  * 源节点没有找到数据, 会返回一个ASK错误, 让客户端去新槽找
* 相比于MOVED错误, 这是吃个一次性的临时标记, 只是临时将这一次访问这个槽的请求抓发到新的节点

## 复制和故障转移

* redis集群模式的节点分为主节点和从节点, 主节点负责用于处理槽, 从节点负责复制主节点并在主节点下线时成为新的主节点
  * 客户端通过参数可以允许只读请求发送到从节点
* 所有节点都会定期向其他节点发送PING消息用以检测节点是否掉线, 没有收到回复就会将其标记为疑似下线状态, 并在集群中广播
* 如果发现半数以上的主节点都把这个节点标记为疑似下线, 则将节点视为已经下线, 并广播给其他节点
* 重新选一个从节点作为主节点 Raft
  * 集群的配置纪元是一个自增计数器, 每进行一次故障转移都自增一次
  * 对于每个纪元, 集群的主节点都有一次投票机会, 第一个向主节点要求投票的节点会获得这个节点的票
  * 从节点发现自己复制的主节点已经下线时, 等待一个随机延迟(长度与自己的复制进度有关)
  * 从节点回向集群广播一条 CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST, 要求收到这条消息的主节点投票给自己
  * 如果主节点在本轮投票中没有投票给其他节点, 则返回一条ACK, 表示支持
  * 所有从节点根据回复确定得票情况, 确定有无节点得票过半, 称为新的主节点, 如果没有则稍后再选举
* 新的主节点执行slaveof no one
* 新的主节点撤销对已下线使得主节点的槽的指派, 并且指派给自己
* 向集群广播自己称为新的主节点,  同时接管了原来的这些槽