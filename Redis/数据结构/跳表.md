# 数据结构: 跳表

## 特性

* 有score的操作平均O(log(N)), 最差O(N)的复杂度查找
  * 大部分情况性能与平衡搜索树差不多, 但是算法更为简单, 所以经常用来代替平衡搜索树
* 没有score只能用第一层链表来遍历
  * 所以经常搭配hash表来保存score, 如redis的zset                                                                         
* 可以通过顺序进行操作节点

## 跳表的实现

* hearder: 指向跳表的头节点
* tail: 指向跳表的尾节点
* level: 跳表的层数
* length: 跳表的长度

* 层: level
* backward指针: 指向位于当前节点的前一个节点, 用于从表尾遍历到表头

### 节点结构

```c
typedef struct zskiplistNode{
    // 后退指针
    struct zskiplistNode *backward;
    // 分值
    double score;
    // 成员对象
    robj *obj;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
} zskiplistNode;
```

* level数组可以包含多个元素, 每个元素都包含一个指向其他节点的指针, 程序可以通过这些层加速访问替他节点的速度, 一般层数越多, 访问越快
  * 每次创建一个新的跳跃表节点的时候, 随机生成一个介于1-32的值作为层数
* 前进指针: 每层都有一个指向表尾的方向的指针(level[i].forward), 用于从表头像表尾方向访问节点
  * 首先访问跳表的头节点, 从