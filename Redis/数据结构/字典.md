# 数据结构: 字典

## 实现

```c

typedef struct dictEntry{
    void *key;
    union {
        void *value;
        uint64_t u64;
        int64_t s64;
    }v;
    // 指向hash表的另一个节点, 形成链表
    struct dictEntry *next;
}dictEntry;

typedef struct dictht {
    // hash表数组, 每个元素都是一个指向dictEntry的指针
    dictEntry **table;
    // hash表大小
    unsigned long size;
    // 掩码, 用于根据hash结果计算索引值
    unsigned long sizemask;
    // 已有的节点数量
    unsigned long used;
}dictht;

typedef struct dict{
    // 类型特定函数
    dictTpe *type;
    // 私有数据
    void *privatedata;
    // hash表
    dictht ht[2];
    // rehash索引, 没有进行rehash时, 所以长度为-1
    int rehashidx;
}dict;
```

* dict的ht属性一般只有ht[0]在使用, ht[1]仅在发生rehash时使用, 使用ht[0]还是ht[1]与rehash进度有关: 即rehashidx

## hash相关

### hash 算法

* redis选择的算法时MurmurHash算法, 均匀性好, 速度快

### 键冲突处理

* 类似于Java HashMap, 但不会树化, 只通过dictEntry内的next属性指向下一个节点, 使同分配到一个索引的节点形成链表

### rehash

#### 空间分配

* 确定空间大小的规则: 扩容/收缩: 新的容量确定为大/小于原size的第一个2^n的整数
* 按照确定的空间大小为ht[1]分配空间
  
#### 数据迁移

* 将ht[0]的所有键值对全部rehash到ht[1]
* 所有数据都迁移完成之后用ht[1]替换掉ht[0], 是放掉原来的ht[0]

### 渐进式rehash

* 如果hash表的内容较多, 不能一次性直接完成, 需要分段完成

#### 过程

* 为ht[1]分配空间
* 将rehashindex置为0, 表示rehash开始
* 在rehash的期间, 系统在执行用户命令之后花一小部分时间用于将ht[0]的数据迁移到ht[1], 每次迁移一条数据, rehashindex都+1
* 随着系统不断运行, ht[0]的数据会全部迁移完成, 此时将rehashindex设置为-1

#### 渐进式rehash期间对hash表的操作

* 新增操作只会在ht[1]进行, 使得旧的hash表只减不增
* 查找删除修改两边同步进行
