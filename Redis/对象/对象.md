# 对象

* 基于数据结构提供给用户使用的结构, 如字符串, 列表, hash等

## 结构

```
typedef struct redisObject{
    // 对象类型
    unsigned type:4;
    // 编码
    unsigned encoding:4;
    // 指向底层数据结构的指针
    void *ptr;
    // ...
}
```

### 可用编码方式

* 编码方式省略前缀 REDIS_ENCONDING_

| 对象类型 | 编码方式 | 说明                                     |
| -------- | -------- | ---------------------------------------- |
| String   | INT      | 整数字符串对象                           |
| String   | EMBSTR   | embstr编码的简单动态字符串对象, 一般<44B |
| String   | RAW      | 简单动态字符串对象, 一般>44B             |
| List     | ZIPLIST  | 压缩列表编码的列表对象                   |
| List     | LINKLIST | 双端链表实现的列表对象                   |
| SET      | INTSET   | 使用压缩列表实现的集合                   |
| SET      | HT       | 使用字典实现的集合对象                   |
| Hash     | ZIPLIST  | 压缩列表实现的Hash对象                   |
| Hash     | HT       | 字典实现的Hash对象                       |
| ZSET     | ZIPLIST  | 压缩列表实现的有序集合对象               |
| ZSET     | SKIPLIST | 跳表+字典实现的有序结合对象              |


## 字符串对象

### embstr和raw

* raw需要两次内存分配, 分别创建redisObj和sdshdr
* embstr只要一块内存, redisObj内容和sdshdr在一块连续内存
  * 一旦内容发生修改, 就会变为raw方式编码

## 列表对象

### 使用ziplist的默认条件(可配置)

* 所有元素大小<64字节
* 元素个数<512
  
## Hash对象

### 使用ziplist编码的默认条件

* 全部key, value<64B
* 键值对个数<512

## 集合对象

### 使用intset的默认条件

* 所有元素都是整数
* 元素个数<512

## 有序集合

### 使用ziplist的条件

* 元素个数<128
* 元素大小<64B

### 为什么使用跳表+字典?

* 跳表的需要带score来操作才能实现O(logN)的复杂度, 否则将退化到链表的O(N)
* 类似判断元素是否存在, 取元素的score这种操作, 如果没有字典, 时间复杂度将会时O(N), 使用hash表之后将会降低到O(1)
* 总的来说就是牺牲空间换时间

## 对象内存回收

* 引用计数法

## 对象LRU

* redisObj记录对象的最近访问时间, 可以计算对象空转时间     
